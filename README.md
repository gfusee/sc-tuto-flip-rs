# ElrondFlip

This repository is a tutorial about building a smart contract on Elrond.

Links to tutorial :

üá´üá∑ - https://twitter.com/gfusee33/status/1515011670732677132

üá∫üá∏ - COMING SOON


# Tutoriel en fran√ßais

## SOMMAIRE

- [INTRODUCTION : Cr√©er une dApp de flip sur Elrond](#introduction)
- [PARTIE 2A: R√©flexions fonctionnelles](#partie2a)
- [PARTIE 2B: Initialisation du projet](#partie2b)
- [PARTIE 2C: Storage du contrat](#partie2c)
- [PARTIE 2D: Administration du contrat](#partie2d)
- [PARTIE 2E: Logique de la mise d‚Äôun joueur](#partie2e)
- [PARTIE 2F: R√©sultat du flip](#partie2f)
- [PARTIE 2G: Bounty](#partie2g)
- [PARTIE 2H: Tests](#partie2h)
- [PARTIE 2: R√©capitulatif](#partie2_recap)

## <a name="introduction"></a>INTRODUCTION : Cr√©er une dApp de flip sur Elrond

L'application que l'on va d√©velopper ensemble est un flip : un "**quitte ou double**" o√π un joueur a une chance sur deux de doubler sa mise.

Ce tutoriel sera divis√© en 3 parties : 
- installation des outils de dev
- d√©veloppement du smart contract
- d√©veloppement de l'interface web

Ce que nous allons faire :

- Coder un smart contract
- D√©ployer le smart contract
- Coder l'interface web et int√©ragir avec le contract
- Parler de quelques bonnes pratiques

Ce que nous n'allons PAS faire :

- Coder de facon optimis√©e, on va pr√©f√©rer la lisibilit√© pour toucher les d√©butants
- Faire une interface jolie, le but de ce thread est de dev
- D√©ployer de facon propre & s√©curis√©e le tout (s'il y a bcp de demande on peut se faire ca en bonus)

## <a name="partie1"></a>PARTIE 1 : Setup de l'environnement de dev

Tout d‚Äôabord il vous faudra installer **erdpy**, il s‚Äôagit d‚Äôun outil vous permettant de compiler, tester et debuguer vos smart contracts, pour l‚Äôinstaller suivez la doc Elrond : [Elrond doc installing erdpy](https://docs.elrond.com/sdk-and-tools/erdpy/installing-erdpy/)

Une fois l‚ÄôIDE install√© on va lui rajouter des plugins, pour **VSCode** il vous faudra l‚Äôextension officielle d‚ÄôElrond: [VScode Elrond extension](https://marketplace.visualstudio.com/items?itemName=Elrond.vscode-elrond-ide)

Pour **IntelliJ** on recommande le plugin Rust, pour l'installer vous allez au d√©marrage dans l'onglet "**Plugins**" et vous recherchez **Rust**.

On va tester l‚Äôinstallation rapidement en t√©l√©chargeant un contrat d‚ÄôElrond et en le compilant :

- Cr√©ez un nouveau dossier pour stocker les fichier du contract, puis ouvrez un terminal et positionnez-vous dans ce dossier avec la commande `cd <chemin du dossier>`

- Une fois dans le dossier lancez la commande `erdpy contract new adder --template adder`

- Si tout se passe bien 2 dossiers vont se cr√©er : **adder** et **erdjs-snippets**

- Placez-vous dans le dossier adder (commande `cd adder`) et lancez la commande `erdpy contract build` qui va avoir pour effet de compiler le contrat.

- Laissez tourner, si √† la fin vous voyez **WASM file generated: blablabla** alors votre installation tourne niquel et vous √™tes pr√™ts pour la partie 2 o√π nous allons coder le contrat.

## <a name="partie2a"></a>PARTIE 2A: R√©flexions fonctionnelles

Vous avez votre environnement de pr√™t? Parfait car nous n'allons pas encore coder.
On va se poser calmement et faire un petit cahier des charges de ce que notre contrat fera, comment et avec quelles pr√©cautions.

On va donc d√©velopper un contrat de flip, on aimerait plusieurs choses, tout d'abord que lorsqu'un joueur mise il ait une chance sur deux de doubler (la base du jeu donc).

On souhaite aussi prendre des frais (en % de la mise) sur le montant doubl√© en cas de victoire.

L'argent qui va √™tre remport√© par les joueurs gagnants n'appara√Æt pas par magie, il faudra que nous l'alimentions nous-m√™me

Imaginons que nous alimentions avec 5 EGLD, avec 5 flips gagnants cons√©cutifs de 1 EGLD le contrat serait √† court de liquidit√©.

5 flips sur 5 gagnants = 3.13% de chances (loi binomiale)

Il faut donc faire jouer la loi faible des grands nombres en jouant sur deux leviers : la quantit√© d'EGLD que nous allons donner au contrat et la mise maximale autoris√©e (on va ici mettre 10% et max 1 EGLD).

Autre chose importante on doit √©viter √† tout prix d'effectuer la mise d'un joueur ET la g√©n√©ration de l'al√©atoire pour le flip dans le m√™me bloc afin de ne pas se prendre une attaque dans la gueule.

Imaginez que le flip se fasse dans la m√™me tx que celle o√π le joueur mise, il suffirait √† un joueur malveillant d'avoir un clone identique de la blockchain, de tester sa tx sur ce clone et de soumettre la transaction √† la vraie blockchain uniquement si le r√©sultat est gagnant.

Pour faire simple sur Elrond les "nombres al√©atoires" sont possibles contrairement √† Ethereum, si on est au bloc N les nombres al√©atoires des blocs N+1, N+2, etc... sont impr√©visibles car ils d√©pendent de la signature des validateurs des blocs pr√©c√©dents.

Mais lorsque nous sommes au bloc N les nombres al√©atoires de ce m√™me bloc N sont pr√©visibles et calculables et heureusement, sinon comment prouver qu'un noeud n'est pas malveillant si on peut pas recalculer le r√©sultat d'une transaction?

Un oracle permettrait aussi √©videmment de contourner le probl√®me mais cette solution rendrait ce thread bien trop compliqu√©.

On va r√©soudre ce probl√®me en faisant le flip en deux transactions, la premi√®re o√π le joueur place sa mise et la deuxi√®me o√π le flip sera r√©alis√©.

Mais petite subtilit√©, n'importe qui pourra faire la deuxi√®me transaction qui g√©n√©rera l'al√©atoire du flip
Pour inciter d'autres utilisateurs (joueur ou non) √† faire cette transaction on va les r√©mun√©rer avec % de la mise!

En clair si joueur A place 1 EGLD au bloc N, d√®s le bloc N+1 un utilisateur B pourra g√©n√©rer son flip et touchera un % de la mise de 1 EGLD
√âvidemment premier arriv√© premier servi afin de ne pas laisser le temps de tester sur une blockchain clon√©e.

## <a name="partie2b"></a>PARTIE 2B: Initialisation du projet

On va commencer par se placer avec le terminal dans le dossier o√π vous aller cr√©er le projet, dans mon cas `~/Documents/Elrond` puis on va lancer la commande `erdpy contract new flip ‚Äìtemplate empty`, un nouveau dossier ‚Äú**flip**‚Äù va appara√Ætre.

Ouvrir le projet avec votre IDE.

Renommer `/flip/src/empty.rs` ‚Üí `/flip/src/lib.rs` en utlisant l‚Äôoutil **Refactor**

![IDE refactor](tutorial/partie2b_1.jpg)

Ensuite dans notre fichier `lib.rs`, on va renommer le **EmptyContract** en **FlipContract**, pareil on va pas le faire √† la main mais utiliser l‚Äôoutil de refactor de notre IDE:

![IDE rename](tutorial/partie2b_2.jpg)

Maintenant on va changer la version du compilateur Elrond, on va se fixer une version afin que personne ne soit perdu, imaginez si quelqu‚Äôun lit ce thread dans 3 mois et que des mises √† jour du framework ont chang√© la fa√ßon de coder cette personne sera compl√®tement perdue.

J‚Äôai choisi la version `0.30.0` car c‚Äôest la version la plus √† jour au moment o√π je code ce contrat

Petit update de derni√®re minute: la version `0.31.1` est sortie, on ne va pas l‚Äôutiliser pour ce thread mais je vous encourage √©videmment √† l‚Äôutiliser dans vos projets.

Pour changer la version on va dans le fichier `Cargo.toml` et on change les version d‚Äô`elrond-wasm-XXX` pour mettre la `0.30.0`.

```rust
[package]
name = "flip"
version = "0.0.0"
authors = [ "you",]
edition = "2018"
publish = false

[lib]
path = "src/lib.rs"

[dev-dependencies]
num-bigint = "0.4.2"

[dependencies.elrond-wasm]
version = "0.30.0"

[dev-dependencies.elrond-wasm-debug]
version = "0.30.0"
```

Et on fait la m√™me modification dans les `Cargo.toml` des dossiers `wasm` et `meta`, √† ce stade l√† si on compile avec la commande `erdpy contract build` tout devrait bien se passer.

Le projet est setup! 

## <a name="partie2c"></a>PARTIE 2C: Storage du contrat

On va cr√©er un nouveau fichier `storage.rs` dans le dossier `src`, ouvrez le fichier et sur **Intellij** vous devriez avoir un avertissement **File is not included in module tree, [...]**, s√©lectionnez **Attach file to lib.rs**

On va d√©clarer un module `StorageModule` dans le fichier `storage.rs`, pour vulgariser on peut voir un module comme une collection de code, √ßa permet de ne pas avoir un fichier `lib`.rs qui fait 30000 lignes.

On √©crit pour cela le code suivant dans `storage.rs`

```rust
elrond_wasm::imports!();

#[elrond_wasm::derive::module]
pub trait StorageModule {

}
```

Il faut maintenant dire √† notre contrat que notre module existe (je vulgarise tr√®s fortement en disant √ßa), dans notre fichier `lib.rs` on le fait ainsi :

```rust
#![no_std]

mod storage;

elrond_wasm::imports!();

#[elrond_wasm::derive::contract]
pub trait FlipContract:
    storage::StorageModule
{
    #[init]
    fn init(&self) {}
}
```

On va aussi avoir besoin de stocker des types plus complexes que des nombres ou des cha√Ænes de caract√®res, comme l‚Äôensemble des infos d‚Äôun flip (l‚Äôadresse du joueur, le block sur lequel le flip est initi√©, etc...)

On voit dans ce code par exemple qu‚Äôun Flip contient un **id, l‚Äôadresse du joueur, le token du flip**, etc... (ouais j‚Äôai oubli√© de pr√©ciser mais le flip pourra se faire sur d‚Äôautres tokens que EGLD lol).

On va donc cr√©er un fichier `struct.rs` dans lequel nous allons d√©clarer nos types personalis√©s (nos structures).
On y place le code suivant:

```rust
elrond_wasm::imports!();
elrond_wasm::derive_imports!();

#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, TypeAbi)]
pub struct Flip<M : ManagedTypeApi> {
    pub id: u64,
    pub player_address: ManagedAddress<M>,
    pub token_identifier: TokenIdentifier<M>,
    pub token_nonce: u64,
    pub amount: BigUint<M>,
    pub bounty: BigUint<M>,
    pub block_nonce: u64,
    pub minimum_block_bounty: u64
}
```

On va maintenant placer nos variables qui vont √™tre stock√©es dans la blockchain (le storage).

On se place √† l‚Äôint√©rieur de `StorageModule` dans `storage.rs` et on va y ajouter le code suivant :

```rust
#[view(getOwnerPercentFees)]
#[storage_mapper("owner_percent_fees")]
fn owner_percent_fees(&self) -> SingleValueMapper<Self::Api, u64>;

#[view(getBountyAmount)]
#[storage_mapper("bounty_percent_fees")]
fn bounty_percent_fees(&self) -> SingleValueMapper<Self::Api, u64>;
```

On a ici rajout√© 2 variables qui vont d√©terminer :

- le % que nous allons prendre sur chaque flip
- le % que va prendre la personne qui va g√©n√©rer l‚Äôal√©atoire (cf partie 1a)

On va appeler ‚Äúbounty‚Äù l‚Äôaction de gagner un % du flip en contrepartie de la g√©n√©ration de l‚Äôal√©atoire.

Pour donner un ordre de grandeur, 100000000 = 100%, ainsi par exemple mettre `owner_percent_fees` √† 5000000 c‚Äôest prendre 5% de frais.

On fait ainsi car les nombres √† virgule (flottants) n‚Äôexistent pas quand on dev un smart contract, diviser par 100000000 au lieu de 100 permet de faire des frais plus pr√©cis comme 1.57% par exemple.

Maintenant nous allons rajouter les variables pour limiter la mise maximale :

```rust
#[view(getMaximumBet)]
#[storage_mapper("maximum_bet")]
fn maximum_bet(
    &self,
    token_identifier: &TokenIdentifier<Self::Api>,
    token_nonce: u64
) -> SingleValueMapper<Self::Api, BigUint<Self::Api>>;

#[view(getMaximumBetPercent)]
#[storage_mapper("maximum_bet_percent")]
fn maximum_bet_percent(
    &self,
    token_identifier: &TokenIdentifier<Self::Api>,
    token_nonce: u64
) -> SingleValueMapper<Self::Api, u64>;
```

`maximum_bet` repr√©sente la mise maximale possible pour un certain token, `maximum_bet_percent` aussi mais en % (m√™me √©chelle qu‚Äôau-dessus)  du nombre du token que poss√®de le contrat.

Par exemple on met `maximum_bet` √† 1 $EGLD et `maximum_bet_percent` √† 10%, la mise maximale autoris√©e sera le + petit d‚Äôun des deux nombres suivants :

- 1 $EGLD
- 10% du nombre d‚ÄôEGLD que poss√®de le contrat

On va rajouter une variable qui d√©termine le nombre de blocks √† attendre avant de pouvoir bounty un flip :

```rust
#[view(getMinimumBlockBounty)]
#[storage_mapper("minimum_block_bounty")]
fn minimum_block_bounty(&self) -> SingleValueMapper<Self::Api, u64>;
```

Puis une variable qui nous indique la r√©serve d‚Äôun token disponible pour les flips:

```rust
#[view(getTokenReserve)]
#[storage_mapper("token_reserve")]
fn token_reserve(
    &self,
    token_identifier: &TokenIdentifier<Self::Api>,
    token_nonce: u64
) -> SingleValueMapper<Self::Api, BigUint<Self::Api>>;
```

Vous allez me dire qu‚Äôon pourrait juste r√©cup√©rer la balance du token pour notre contrat, et bien √ßa ne marcherait pas vraiment.

En effet, un flip se fait en 2 temps, la mise puis l‚Äôexecution via le bounty, mais entre ces deux moments il faut bloquer l‚Äôargent afin d‚Äôavoir de quoi payer en cas de victoire du joueur, c‚Äôest √† √ßa que sert cette variable

Intuitivement, `token_reserve = balance - token bloqu√©s`

Et pour finir on va rajouter 3 variables concernant notre flip :

```rust
#[view(getFlipForId)]
#[storage_mapper("flip_for_id")]
fn flip_for_id(&self, id: u64) -> SingleValueMapper<Self::Api, Flip<Self::Api>>;

#[view(getLastFlipId)]
#[storage_mapper("last_flip_id")]
fn last_flip_id(&self) -> SingleValueMapper<Self::Api, u64>;

#[view(getLastBountyFlipId)]
#[storage_mapper("last_bounty_flip_id")]
fn last_bounty_flip_id(&self) -> SingleValueMapper<Self::Api, u64>;
```

`flip_for_id` contient les infos sur un flip (notre struct Flip d√©clar√©e un peu + haut)

Parlons rapidement des deux autres variables:

`last_flip_id` repr√©sente l‚Äôid du dernier flip fait, on fait +1 √† chaque fois qu‚Äôun joueur place une mise.

`last_bounty_flip_id` repr√©sente le dernier flip pour lequel a d√©j√† eu lieu l‚Äôex√©cution.

Lorsque quelqu‚Äôun va vouloir bounty, il ne va pas g√©n√©rer l‚Äôal√©atoire pour un flip mais pour tous les flips entre `last_bounty_flip_id` et `last_flip_id` (en prenant en compte minimal_block_bounty) en one shot (et donc plusieurs rewards d‚Äôun coup).

## <a name="partie2d"></a>PARTIE 2D: Administration du contrat

On va cr√©er un module `AdminModule` dans un nouveau fichier `admin.rs` dans le dossier `src`.

Notez bien que nous lui ‚Äú**indiquons l‚Äôexistence**‚Äù de `StorageModule` (je vulgarise ne me tombez pas dessus lol)

```rust
use crate::storage;
elrond_wasm::imports!();

#[elrond_wasm::derive::module]
pub trait AdminModule:
    storage::StorageModule
{
    
}
```

Et on ajoute ce module √† notre contrat dans `lib.rs`

```rust
#![no_std]

mod storage;
mod admin;
mod structs;

elrond_wasm::imports!();

#[elrond_wasm::derive::contract]
pub trait FlipContract:
    storage::StorageModule + admin::AdminModule
{
    #[init]
    fn init(&self) {}
}
```

On se replace dans `AdminModule` puis on va tout d‚Äôabord cr√©er un endpoint pour augmenter la r√©serve totale d‚Äôun token:

```rust
#[payable("*")]
#[endpoint(increaseReserve)]
fn increase_reserve(
    &self,
    #[payment_token] payment_token: TokenIdentifier<Self::Api>,
    #[payment_nonce] payment_nonce: u64,
    #[payment_amount] payment_amount: BigUint<Self::Api>
) {

    require!(
        payment_amount > 0u64,
        "zero payment"
    );

    self.token_reserve(
        &payment_token,
        payment_nonce
    ).update(|reserve| *reserve += payment_amount);

}
```

Rien de fou mais notez qu‚Äôon ne s√©curise pas cet endpoint par only_owner, si un utilisateur lambda veut gentillement nous donner de l‚Äôargent on accepte √©videmment.

On rajoute un endpoint pour r√©cup√©rer la r√©serve de token non utilis√©e:

```rust
#[only_owner]
#[endpoint(withdrawReserve)]
fn withdraw_reserve(
    &self,
    token_identifier: TokenIdentifier<Self::Api>,
    token_nonce: u64,
    amount: BigUint<Self::Api>
) {
    let token_reserve = self.token_reserve(
        &token_identifier,
        token_nonce
    ).get();

    require!(
        amount <= token_reserve,
        "amount too high"
    );

    self.send()
        .direct(
            &self.blockchain().get_caller(),
            &token_identifier,
            token_nonce,
            &amount,
            &[]
        );
}
```

Cet endpoint est √©videmment s√©curis√© `only_owner` (seul l‚Äôowner peut l‚Äôutiliser) et le require est important, sans ce dernier on pourrait rug avec l‚Äôargent des flip en cours.

Dans ce monde faites confiance au code, pas aux humains.

Ensuite on va rajouter 3 endpoints 
- `only_owner` pour changer `maximum_bet`, 
- `maximum_bet_percent`
- `minimum_block_bounty`

```rust
#[only_owner]
#[endpoint(setMaximumBetPercent)]
fn set_maximum_bet_percent(
    &self,
    token_identifier: TokenIdentifier<Self::Api>,
    token_nonce: u64,
    percent: u64
) {

    require!(
        percent > 0u64,
        "percent zero"
    );

    self.maximum_bet_percent(
        &token_identifier,
        token_nonce
    ).set(percent);

}

#[only_owner]
#[endpoint(setMaximumBet)]
fn set_maximum_bet(
    &self,
    token_identifier: TokenIdentifier<Self::Api>,
    token_nonce: u64,
    amount: BigUint<Self::Api>
) {

    require!(
        amount > 0u64,
        "amount zero"
    );

    self.maximum_bet(
        &token_identifier,
        token_nonce
    ).set(amount);

}

#[only_owner]
#[endpoint(setMinimumBlockBounty)]
fn set_minimum_block_bounty(
    &self,
    minimum_block_bounty: u64
) {

    require!(
        minimum_block_bounty > 0u64,
        "minimum_block_bounty zero"
    );

    self.minimum_block_bounty().set(minimum_block_bounty);

}
```

C‚Äôest tout pour la partie administration qui est relativement simple et courte.

La prochaine √©tape va √™tre de faire le code qui va g√©rer le flip et le bounty, √ßa va √™tre un GROS morceau.

## <a name="partie2e"></a>PARTIE 2E: Logique de la mise d‚Äôun joueur

Tout est pr√™t pour coder le coeur du contrat : **la logique de la mise d‚Äôun joueur**.

On se place dans le fichier `lib.rs` (l‚Äôancien `empty.rs` qu‚Äôon a renomm√© dans la partie 2b si vous vous rappelez) et on va y ajouter une constante `HUNDRED_PERCENT` qui repr√©sente l‚Äô√©chelle de nos % (cf partie 2b).

```rust
#![no_std]


const HUNDRED_PERCENT: u64 = 100_000_000;

mod storage;
mod structs;
mod admin;

elrond_wasm::imports!();

#[elrond_wasm::derive::contract]
pub trait FlipContract:// ContractBase +
    storage::StorageModule + admin::AdminModule
{
    #[init]
    fn init(&self) {}
}
```

On va se placer dans le trait `FlipContract` (et on va y rester qq temps) et on va remplacer la fonction d‚Äôinitialisation du contrat:

```rust
#[init]
fn init(
    &self,
    owner_percent_fees: u64,
    bounty_percent_fees: u64,
    minimum_block_bounty: u64
) {
    self.owner_percent_fees().set(owner_percent_fees);
    self.bounty_percent_fees().set(bounty_percent_fees);

    require!(
        minimum_block_bounty > 0u64,
        "minimum_block_bounty is zero"
    );

    self.minimum_block_bounty().set(minimum_block_bounty)
}
```

La fonction annot√©e `#[init]` est une fonction qui va √™tre appel√©e dans deux cas, au premier d√©ploiement du contrat et √† chaque mise √† jour, dans cette fonction nous allons initialiser les valeurs d‚Äôadministration.

Nous allons maintenant nous attaquer √† l‚Äôendpoint `flip` qui va permettre √† un joueur de placer sa mise, on commencer par le d√©clarer:

```rust
#[payable("*")]
#[endpoint]
fn flip(
    &self,
    #[payment_amount] payment_amount: BigUint<Self::Api>,
    #[payment_token] payment_token: TokenIdentifier<Self::Api>,
    #[payment_nonce] payment_nonce: u64
) {


}
```

On se place maintenant √† l‚Äôint√©rieur de l‚Äôendpoint `flip` (et on y restera jusqu‚Äô√† nouvel ordre), on va commencer par faire quelques v√©rifications:

```rust
let token_reserve = self.token_reserve(
    &payment_token,
    payment_nonce
).get();

require!(
    token_reserve > 0u64,
    "no token reserve"
);

require!(
    !self.maximum_bet(&payment_token, payment_nonce).is_empty(),
    "no maximum bet"
);

require!(
    !self.maximum_bet_percent(&payment_token, payment_nonce).is_empty(),
    "no maximum bet percent"
);
```

La premi√®re v√©rification consiste √† v√©rifier que le contrat dispose bien de fonds pour effectuer un flip pour le token cible.

cette v√©rification sera un √©chec si par exemple on a pas appel√© `increaseReserve` dans notre fichier `admin.rs` (cf partie 2d) ou si le contrat n‚Äôa plus de liquidit√© suite √† une s√©rie de victoires.

Les deux v√©rifications suivantes v√©rifient que nous avons bien pr√©cis√© les valeurs de mises maximales pour le token cibl√© (cf parties 2c et 2d)

On va maintenant v√©rifier que l‚Äôutilisateur n‚Äôa pas mis une mise trop importante par rapport √† la liquidit√© que poss√®de notre contrat (via `maximum_bet_percent`) ou la mise maximale que nous avons autoris√©e (via `maximum_bet`)

On commence par calculer la mise maximale autoris√©e, on met √† la suite du code pr√©c√©dent.

```rust
let maximum_bet = self.maximum_bet(
    &payment_token,
    payment_nonce
).get();

let maximum_bet_percent = self.maximum_bet_percent(
    &payment_token,
    payment_nonce
).get();

let max_allowed_bet = min(
    maximum_bet,
    token_reserve * &BigUint::from(maximum_bet_percent) / HUNDRED_PERCENT
);
```

Si min est en rouge c‚Äôest que la fonction n‚Äôest pas import√©e, pour ce faire passez le curseur dessus et s√©lectionnez ‚ÄúImport‚Äù.

Puis les mises qui iront √† nous et au bounty via les frais, et la mise r√©elle du joueur (frais exclus), toujours √† la suite du code pr√©c√©dent

```rust
let owner_profits = &payment_amount * &BigUint::from(self.owner_percent_fees().get()) / HUNDRED_PERCENT;
let bounty = &payment_amount * &BigUint::from(self.bounty_percent_fees().get()) / HUNDRED_PERCENT;
let amount = &payment_amount - &bounty - &owner_profits;
```

La premi√®re valeur ira directement √† l‚Äôowner qq lignes plus tard (on y viendra), la deuxi√®me valeur sera la r√©compense pour la personne qui va g√©n√©rer l‚Äôal√©atoire  et la troisi√®me valeur est la mise r√©elle du joueur (celle qui sera doubl√©e en cas de victoire)

On peut maintenant v√©rifier que la mise ne d√©passe pas le maximum autoris√©, encore √† la suite du code pr√©c√©dent

```rust
require!(
    amount <= max_allowed_bet,
    "too much bet"
);
```

A partir de maintenant toutes les v√©rifications sont faites, on a plus qu‚Äô√† agir, on calcule tout d‚Äôabord le nouvel id de notre flip (qui vaut l‚Äôid du dernier flip + 1)

```rust
let last_flip_id = if self.last_flip_id().is_empty() {
    0u64
} else {
    self.last_flip_id().get()
};

let flip_id = last_flip_id + 1;
```

Et on instancie les infos du flip

```rust
let flip = Flip {
    id: flip_id,
    player_address: self.blockchain().get_caller(),
    token_identifier: payment_token.clone(),
    token_nonce: payment_nonce,
    amount: amount.clone(),
    bounty: bounty.clone(),
    block_nonce: self.blockchain().get_block_nonce(),
    minimum_block_bounty: self.minimum_block_bounty().get()
};
```

Si Flip est en rouge c‚Äôest qu‚Äôil n‚Äôest pas import√©, pour ce faire passez le curseur dessus et s√©lectionnez ‚ÄúImport‚Äù

On bloque le montant de la mise en retirant le montant de `token_reserve`:

```rust
self.token_reserve(
    &payment_token,
    payment_nonce
).update(|reserve| *reserve -= &amount);
```

Et on s‚Äôenvoie directement les frais du flip, on a pas besoin d‚Äôattendre que le flip soit effectu√©:

```rust
self.send()
    .direct(
        &self.blockchain().get_owner_address(),
        &payment_token,
        payment_nonce,
        &owner_profits,
        &[]
    );
```

Tout s‚Äôest bien pass√©, plus qu‚Äô√† inscrire dans le storage l‚Äôexistence du flip:

```rust
self.flip_for_id(flip_id).set(flip); 
self.last_flip_id().set(flip_id);
```

On a termin√© l‚Äôendpoint ‚Äúflip‚Äù ! A ce stade notre utilisateur peut placer sa mise et les frais sont calcul√©s, la suite consiste √† √©crire le code qui permet de r√©aliser le flip.

## <a name="partie2f"></a>PARTIE 2F : R√©sultat du flip

Nous avons notre flip d‚Äôinitialis√©, nous allons dans cette partie le r√©aliser

On se place dans le trait `FlipContract` (fichier `lib.rs`) et nous allons cr√©er une fonction `make_flip`

Cette partie sera donc consacr√© √† l'√©criture de cette fonction.

```rust
fn make_flip(
    &self,
    bounty_address: &ManagedAddress<Self::Api>,
    flip: &Flip<Self::Api>
) { }
```

Cette fonction, qui n‚Äôest pas un endpoint, aura comme objectif de r√©aliser un flip en faisant trois actions :

- D√©terminer si le flip est gagnant ou perdant
- Envoyer le gain au joueur en cas de victoire ou augmenter `token_reserve` en cas de d√©faite
- Envoyer la r√©compense √† celui qui g√©n√®re l‚Äôal√©atoire (`bounty_address`)

On commence par d√©terminer si le flip est gagnant:

```rust
let mut rand_source = RandomnessSource::<Self::Api>::new();
let random_number = rand_source.next_u8_in_range(0, 2);
let is_win = random_number == 1u8;
```

Le code ci-dessus va g√©n√©rer un nombre al√©atoire entre 0 et 2 (exclus) donc soit 0 soit 1, on consid√®re que le flip est gagn√© si ce nombre vaut 1, on a donc bien une chance sur deux de gagner.

On va maintenant g√©rer les transferts d‚Äôargent en fonction du r√©sultat:

```rust
if is_win {
    self.send()
        .direct(
            &flip.player_address,
            &flip.token_identifier,
            flip.token_nonce,
            &profit_if_win,
            &[]
        );
} else {
    self.token_reserve(
        &flip.token_identifier,
        flip.token_nonce
    )
        .update(|reserve| *reserve += &profit_if_win);
}
```

Dans le cas d‚Äôune d√©faite nous ajoutons le profit (= double du montant du flip) √† la r√©serve, pourquoi le montant doubl√© et pas juste le montant ?

Tout simplement car au moment o√π un joueur place sa mise (cf partie pr√©c√©dente), le smart contract re√ßoit dans sa balance le montant MAIS on ne l‚Äôajoute pas √† la r√©serve

Mais non seulement on ajoute pas le montant √† la r√©serve mais en + on le retire, il faut donc en cas de d√©faite ajouter √† la r√©serve deux fois le montant

Pour terminer on envoie le bounty √† bounty_address (cf partie suivante o√π on cr√©era l‚Äôendpoint qui appelle notre fonction `make_flip`)

Et on enl√®ve du storage le flip qui vient d‚Äô√™tre r√©alis√©:

```rust
self.send()
    .direct(
        &bounty_address,
        &flip.token_identifier,
        flip.token_nonce,
        &flip.bounty,
        &[]
    );

self.flip_for_id(flip.id).clear();
```

Voil√† qui termine cette petite partie sur le r√©sultat du flip, prochaine partie nous allons g√©rer le bounty.

## <a name="partie2g"></a>PARTIE 2G : Bounty

On sait maintenant comment r√©aliser le flip, il reste juste √† cr√©er l‚Äôendpoint associ√©

Normalement il s‚Äôagit de l‚Äôavant dernier thread de la partie **smart contract** de cette longue s√©rie.

On va rajouter un endpoint, toujours dans `FlipContract` dans le fichier `lib.rs`, qu‚Äôon va appeler `flip_bounty`

```rust
#[endpoint(flipBounty)]
fn flip_bounty(
    &self
) {}
```

Cette endpoint va √™tre appel√© par n‚Äôimporte quelle adresse et aura comme objectif de :

- r√©aliser tous les flips en attente d‚Äôun coup
- donner le bounty de chaque flip √† la personne qui a appel√© l‚Äôendpoint

On va commencer par interdire aux smarts contracts d‚Äôappeler cet endpoint afin de rendre la pr√©diction des nombres al√©atoires plus difficile:

```rust
let caller = self.blockchain().get_caller();

require!(
    !self.blockchain().is_smart_contract(&caller),
    "caller is a smart contract"
);
```

On va ensuite r√©cup√©rer l‚Äôid du dernier flip r√©alis√© et l‚Äôid du dernier flip en attente.

Par exemple si l‚Äôid du dernier flip r√©alis√© est 3 et l‚Äôid du dernier flip en attente est 8 on va tenter de r√©aliser les flips 4, 5, 6, 7 et 8.

Je dis tenter car supposons que les flips 7 et 8 ont √©t√© r√©alis√©s dans le m√™me bloc que l‚Äôappel de `flip_bounty` on ne va PAS les r√©aliser, je vous renvoie √† la partie 2A.

On rajoute donc le code suivant:

```rust
let last_bounty_flip_id = self.last_bounty_flip_id().get();
let last_flip_id = self.last_flip_id().get();

require!(
    last_bounty_flip_id < last_flip_id,
    "last bounty flip id >= last flip id"
);
```

On va initialiser l‚Äôit√©ration sur tous les flips potentiels √† r√©aliser:

```rust
let current_block_nonce = self.blockchain().get_block_nonce();

let mut bounty_flip_id = last_bounty_flip_id;

while bounty_flip_id < last_flip_id {
    
    // On va √©crire du code ici

    bounty_flip_id += 1u64;
}
```

A chaque it√©ration on va :

- R√©cup√©rer les infos du flip
- V√©rifier si le flip est sur un bloc ant√©rieur au bloc actuel
- R√©aliser le flip (via `make_flip` du thread pr√©c√©dent)

J‚Äôattire rapidement votre attention sur le deuxi√®me point, si on doit r√©aliser les flips 5 √† 30 et que le flip 10 est sur le m√™me bloc que le bloc courant, alors les flips 11 √† 30 aussi

On pourra donc casser la boucle imm√©diatement

Voil√† √† quoi ressemble notre boucle maintenant:

```rust
while bounty_flip_id < last_flip_id {
    let flip_id = bounty_flip_id + 1u64;

    if self.flip_for_id(flip_id).is_empty() {
        break;
    }

    let flip = self.flip_for_id(flip_id).get();

    if current_block_nonce < flip.block_nonce + flip.minimum_block_bounty {
        break;
    }

    self.make_flip(
        &caller,
        &flip
    );

    bounty_flip_id += 1u64;
}
```

On sort de notre boucle et il nous reste que deux choses √† faire :

- Renvoyer une erreur si aucun flip n‚Äôa pu √™tre r√©alis√©
- Enregistrer le dernier flip r√©alis√© dans le storage

On rajoute donc apr√®s la boucle les deux lignes suivantes:

```rust
if bounty_flip_id == last_bounty_flip_id {
    sc_panic!("no bounty")
}

self.last_bounty_flip_id().set(bounty_flip_id);
```

Voil√† qui termine ce thread et le code du smart contract, il nous reste une derni√®re chose √† voir : les tests.

## <a name="partie2h"></a>PARTIE 2H : Tests

Le code du contrat est termin√©, on va se poser tranquillement et parler un peu de tests

Jusqu‚Äô√† pr√©sent on a cod√© mais on a jamais v√©rifi√© si le contrat fonctionnait, nous n‚Äôavons pas non plus d√©ploy√© le contrat donc √† l‚Äôheure actuelle nous avons un contrat qui compile mais qui pourrait tr√®s bien faire des conneries

Il faut donc maintenant s‚Äôassurer que le contrat fait bien ce qu‚Äôon attend de lui, m√™me dans des conditions particuli√®res.

On a donc plusieurs fa√ßon de proc√©der, tout d‚Äôabord la m√©thode na√Øve qui consiste √† d√©ployer le contrat sur un testnet et de tester √† la main de faire des flips, des bounty, des increaseReserve en tant qu‚Äôowner, increaseReserve sans √™tre owner pour check qu‚Äôil y a une erreur, ..

Avantages :

- On peut v√©rifier si √ßa fonctionne

D√©savantages :

- C‚Äôest long
- C‚Äôest chiant
- C‚Äôest risqu√© car erreurs de manip qui peuvent fausser les tests
- Il faut tout refaire √† chaque modification du code pour v√©rifier qu‚Äôon a rien cass√©
- On ma√Ætrise que dalle (entre deux tests le testnet aura chang√©)
- On ne peut pas jouer sur la temporalit√© (perso attendre plusieurs blocs apr√®s une mise pour tester le bounty non merci)

Conclusion : oubliez cette fa√ßon de faire

Ensuite on a la m√©thode ‚Äúna√Øve mais y a de l‚Äôid√©e‚Äù qui consiste √† √©crire un script qui va d√©ployer et faire tous les tests

C‚Äôest comme la m√©thode na√Øve mais automatis√©e, globalement on a le m√™me unique avantage et les m√™mes d√©savantages sauf les erreurs de manip

Vient donc la bonne m√©thode : faire des tests dans un environnement ma√Ætris√© via un framwork

On a sur Elrond deux frameworks de tests : [Mandos](https://docs.elrond.com/developers/mandos-reference/overview/) ou [Rust Testing Framework](https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html)

Le concept est simple : une blockchain va √™tre simul√©e en local et les tests vont √™tre lanc√©s dans cet environnement qui sera TOUJOURS le m√™me

On peut agir sur le storage, faire des avances rapides dans le temps, modifier les balances des adresses, etc‚Ä¶

Je vais personnellement utiliser mandos, pr√©f√©rence personnelle, les deux frameworks font la m√™me chose en bout de cha√Æne donc il n‚Äôy a pas de mauvais choix

Je ne vais pas vous mettre le code des tests il sera disponible dans le thread suivant o√π je publierai tout le code du contrat

Je vais plut√¥t faire une liste non exhaustif des tests que j‚Äôai r√©alis√© afin que vous ayez une id√©e :

- Mise d‚Äôun joueur
- Bounty d‚Äôun flip gagnant
- Bounty d‚Äôun flip perdant
- Mise de plusieurs personnes sur des blocs diff√©rents
- Bounty de plusieurs flips dont certains sur le m√™me bloc que le bloc courant

A titre personnel les tests repr√©sentent 70% de mon temps et 30% c‚Äôest coder le smart contract.

## <a name="partie2_recap"></a>PARTIE 2 : R√©capitulatif

On a fini la partie smart contract du flip

On a un contrat de flip fonctionnel qui poss√®de une petite s√©curit√© contre les attaques sur les nombres al√©atoires.

Cette s√©curit√© consiste en bref √† payer des utilisateurs autres que les joueurs pour nous fournir l'al√©atoire, pour que √ßa fonctionne il faut donc un minimum de trafic.

Notre flip peut se faire sur n'importe quel token du moment que le contrat poss√®de une r√©serve de ce token, la mise maximale d√©pend de cette r√©serve

La suite consiste √† cr√©er le site web qui va se connecter au contrat, on pourra aussi regarder pour cr√©er un script de d√©ploiement automatis√© du contrat.
